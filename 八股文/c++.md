## 指针和引用的区别
 1. 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名;
 2. 指针可以有多级，引用只有一级;
 3. 指针可以为空,引用不能为NULL且在定义时必须初始化;
 4. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变;
 5. sizeof指针得到的是本指针的大小,sizeof引用得到的是引用所指向变量的大小;
 6. 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以;
 7. 引用一旦初始化之后就不可以再改变(变量可以被引用为多次，但引用只能作为一个变量引用);指针变量可以重新指向别的变量;
 8. 不存在指向空值的引用，必须有具体实体;但是存在指向空值的指针。

## new/delete 和 malloc/free的区别
 1. malloc/free是C/C++标准库的函数，new/delete是C++的运算符;
 2. malloc/free只是动态分配内存空间/释放空间，而new/delete除了分配空间还会调用构造函数和析构函数;
 3. malloc/free需要手动计算类型大小并传递，new/delete可自己计算类型的大小;  

 ## 结构体内存对齐问题
规则如下：
1. 起始成员 以地址 0 起始
2. 某一成员需要对齐到 该类型所占字节数的地址的倍数，如：
    - int: 4的倍数
    - short: 1的倍数
3. 结构体总大小需要对齐到 最大成员类型所占字节数或操作系统编译环境位数中较小的一个
4. 嵌套规则: 外层结构体 对齐倍数为 内层结构体最大成员类型 和 成员类型 较大者

为什么存在结构体对齐？
空间换时间 提高效率 计算机按字读取（64位）一次性读8个字节，若一个变量被置于单个8字节内则可以一次性读完，若被分置于两个8字节中则需要读取两次

例：64位系统下：
```cpp
struct A{
    char a;
    int b;
    double c;
}; // 1+3+4+8 = 16B

struct B{
    double a;
    int b;
    char c;
}; // 8+4+4+1+7 = 24B

struct C{
    int a;
    struct A b; 
    char c;
} // 4+4+16+1+7 = 32B
```
## 空类中有什么函数？
默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符


## c++ 类对象的初始化和析构顺序
构造顺序：
1. 虚基类指针
2. 基类（按声明顺序） 
2. 成员变量（按声明顺序）
3. 构造函数

析构顺序是逆序

=====>为什么初始化列表比构造函数中赋值快？
初始化列表发生于成员变量初始化阶段，如果放在构造函数相当于先进行构造再调用赋值，对于简单数据类型无影响，但对于类对象会有性能降低

## 内存泄漏的检测和避免
内存泄漏分类：
1. malloc/new和free/delete的错误使用：
- 申请后未释放
- 不使用搭配：free释放new
- 使用delete删除申请的数组而不是delete[]
2. 基类函数的析构函数未定义为虚函数
子类资源未能正确释放

避免方法：
1. RAII思想：对象获取即初始化，使用类管理指针，由类负责
2. 计数法：每一次new都++，每一次delete都--
3. 智能指针：但本质只是减少，还是会产生死锁

检测方法：
1. code review
2. 静态检测工具 cpplint
3. 动态检测工具 valgrind


## . C++哪些运算符不能被重载？
1.	点运算符 (.):
-	点运算符用于访问类的成员,不能被重载。
2.	箭头运算符 (->):
-	箭头运算符用于通过指针访问类的成员,不能被重载。
3.	范围解析运算符 (::):
-	范围解析运算符用于访问命名空间或类作用域中的符号,不能被重载。
4.	sizeof 运算符:
-	sizeof 运算符用于获取数据类型或表达式的大小,不能被重载。
5.	typeid 运算符:
-	typeid 运算符用于获取表达式的类型信息,不能被重载。
6.	const 运算符:
-	const 运算符用于声明常量,不能被重载。
7.	?:（三元）运算符:
-	三元运算符用于实现条件表达式,不能被重载。
8.	#、##（预处理器）运算符:
-	预处理器运算符不能被重载。


## 哪些函数不能被声明为虚函数？
1.	构造函数:
-	构造函数不能声明为虚函数,因为在对象还未完全构造好的时候,调用虚函数机制会导致未定义的行为。
2.	静态函数:
-	静态函数不依赖于对象的动态类型,因此不适合使用虚函数的动态绑定机制。
3.	friend 函数:
-	friend 函数不是类的成员函数,因此不能声明为虚函数。
4.	运算符重载函数:
-	运算符重载函数不能声明为虚函数,因为它们不是普通的成员函数。
5.	模板函数:
-	模板函数不能声明为虚函数,因为模板函数在编译时就会被实例化,无法实现动态绑定。
6.	内联函数:
-	内联函数在编译时就会被展开,无法实现动态绑定,因此不能声明为虚函数。


## 为什么 c++ 构造函数不能是虚函数
- 语法层面：
    构造函数负责初始化对象，其中也包括虚函数表指针，不应该在初始化同时使用其
- 机制层面：
    virtual依赖于虚函数表指针，而在构造函数中虚函数表指针尚未存在

=====> 基类的虚函数为什么要是虚函数？
为了当基类指针指向派生类对象时能够正确调用析构函数释放对象

=====> 既然如此，为什么不默认是虚函数？
内存开销 vptr 和 vtable


## c++重载重写隐藏的区别
1. 重载：
在同一作用域下同函数名同返回值不同参数的函数
```cpp
class A{
    int fun(int);
    int fun(int,int);
    int fun(double,int);
};
```

2. 重写：
派生类重写继承自基类的函数，要求函数的返回值名称参数都要一致
```cpp
class Base{
    virtual void func();
}

class Derived:public Base{
    void func() override();
}
```

3. 隐藏：
派生类的同名函数使得基类函数失效
```c++
class Base{
    void func();
}

class Derived:public Base{
    void func();  // Base::func()被隐藏，只能通过Base::func()访问
}
```

## 大小端字节序
大端字节序：（网络字节序）
数据的低字节存在低地址
|      |       |       |       |       |
| ---- | ----- | ----- | ----- | ----- |
| 地址 | 0x100 | 0x101 | 0x102 | 0x103 |
| 内容 | 0x12  | 0x34  | 0x56  | 0x78  |

小端字节序：(主机字节序)
数据的低字节存在高地址
|      |       |       |       |       |
| ---- | ----- | ----- | ----- | ----- |
| 地址 | 0x100 | 0x101 | 0x102 | 0x103 |
| 内容 | 0x78  | 0x56  | 0x34  | 0x12  |

=====>如何判断是大端还是小端字节序？
使用强制类型转换，截断数据的低字节
```c++
int num = 0x1234;
char ch =(char)num;
if(ch == 0x12){
    cout<<"大端"<<endl;
}else {
    cout<<"小端"<<endl;
}
```
