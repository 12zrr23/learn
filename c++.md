## 指针和引用的区别
 1. 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名;
 2. 指针可以有多级，引用只有一级;
 3. 指针可以为空,引用不能为NULL且在定义时必须初始化;
 4. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变;
 5. sizeof指针得到的是本指针的大小,sizeof引用得到的是引用所指向变量的大小;
 6. 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以;
 7. 引用一旦初始化之后就不可以再改变(变量可以被引用为多次，但引用只能作为一个变量引用);指针变量可以重新指向别的变量;
 8. 不存在指向空值的引用，必须有具体实体;但是存在指向空值的指针。

## new/delete 和 malloc/free的区别
 1. malloc/free是C/C++标准库的函数，new/delete是C++的运算符;
 2. malloc/free只是动态分配内存空间/释放空间，而new/delete除了分配空间还会调用构造函数和析构函数;
 3. malloc/free需要手动计算类型大小并传递，new/delete可自己计算类型的大小;  

 ## 结构体内存对齐问题
规则如下：
1. 起始成员 以地址 0 起始
2. 某一成员需要对齐到 该类型所占字节数的地址的倍数，如：
    - int: 4的倍数
    - short: 1的倍数
3. 结构体总大小需要对齐到 最大成员类型所占字节数或操作系统编译环境位数中较小的一个
4. 嵌套规则: 外层结构体 对齐倍数为 内层结构体最大成员类型 和 成员类型 较大者

为什么存在结构体对齐？
空间换时间 提高效率 计算机按字读取（64位）一次性读8个字节，若一个变量被置于单个8字节内则可以一次性读完，若被分置于两个8字节中则需要读取两次

例：64位系统下：
```cpp
struct A{
    char a;
    int b;
    double c;
}; // 1+3+4+8 = 16B

struct B{
    double a;
    int b;
    char c;
}; // 8+4+4+1+7 = 24B

struct C{
    int a;
    struct A b; 
    char c;
} // 4+4+16+1+7 = 32B
```
## 空类中有什么函数？
默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符


## c++ 类对象的初始化和析构顺序
构造顺序：
1. 虚基类指针
2. 基类（按声明顺序） 
2. 成员变量（按声明顺序）
3. 构造函数

析构顺序是逆序

=====>为什么初始化列表比构造函数中赋值快？
初始化列表发生于成员变量初始化阶段，如果放在构造函数相当于先进行构造再调用赋值，对于简单数据类型无影响，但对于类对象会有性能降低

## 野指针和内存泄漏是什么？如何避免？
1. 野指针 (Dangling Pointer):
定义: 指向一块已经被释放或者不再使用的内存区域的指针。
产生原因: 常见于指针所指向的内存区域被释放或者赋值给其他变量后,但指针本身没有被更新。

2. 内存泄漏 (Memory Leak):
定义: 程序中存在动态分配的内存在不需要使用时没有被正确释放,导致内存资源一直无法被回收利用。
产生原因: 常见于动态内存分配后忘记释放、存在循环引用等问题。

- 如何避免野指针和内存泄漏:
- - 野指针:
及时更新指针指向: 在内存区域被释放或赋值后,立即将指针设置为 NULL。
合理初始化指针: 声明指针时应初始化为 NULL 或其他合法值。
谨慎使用指针运算: 小心避免指针越界访问。
- - 内存泄漏:
合理使用动态内存: 动态分配的内存在不需要时应该及时释放。
注意循环引用: 保持对象间引用关系的合理性,避免循环引用。
使
