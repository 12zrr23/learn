## make和new的区别：
1. new(T):
- new 是一个内建函数,用于动态分配内存。
- new(T) 会为类型 T 的新值分配内存,并返回一个指向该内存的指针,类型为 *T。
- 使用 new 分配的内存会被初始化为 T 类型的零值。

2. make(T, args):
- make 是一个内建函数,主要用于创建 slice、map 和 channel。
- make(T, args) 返回的是一个 T 类型的初始化后的值,而不是指针。
- make 函数的参数类型和数量因 T 的类型而不同:
- - 对于 slice: make([]T, len, cap)
- - 对于 map: make(map[K]V, cap)
- - 对于 channel: make(chan T, buffer)

## Go语言中的panic和recover有什么作用？
1. panic和recover是Go语言中用于处理异常的机制。
2. 当程序遇到无法处理的错误时，可以使用panic引发一个异常，中断程序的正常执行。
3. 而recover用于捕获并处理panic引发的异常，使程序能够继续执行。

## defer 语句的执行顺序是"后进先出"(LIFO)的。
```golang
defer wg.Done()
mu.Lock()
defer mu.Unlock()
m[fmt.Sprintf("key%d", id)] = id
```
- 具体执行顺序如下:
- - 执行 m[fmt.Sprintf("key%d", id)] = id
- - 执行 defer mu.Unlock()
- - 执行 defer wg.Done()


## 原子操作和锁是两种不同的同步机制，用于处理并发编程中的同步问题。
1. 原子操作适用于对单个变量的读写操作，具有较低的性能开销。
2. 而锁适用于对一段代码或一组操作的访问进行同步，具有更高的性能开销。
3. 选择使用原子操作还是锁取决于具体的场景和需求。
4. 需要注意的是，原子操作通常用于对共享变量进行简单的读写操作，而锁更适用于对临界区的访问进行复杂的操作和保护。


## 如果往一个已经 close() 的 channel 发送消息
会产生 panic,读取已关闭的 channel 可以获得零值, 若使用 range 读取 channel, 则 close 后会终止循环

## golang中map的底层实现原理
1. map 的底层实现是哈希表(hash table)
2. map 的键必须是可比较的类型,即可以使用 == 运算符进行比较。
3. map 的值可以是任意类型。
4. map 的键值对是无序的。

- map的底层实现是使用哈希表(hash table)来实现的。当两个不同的键映射到了同一个桶时,会发生哈希冲突。Golang 中采用了"链地址法"来解决哈希冲突,即在同一个桶内以链表的形式存储冲突的键值对

## slice底层实现原理
1. slice 实际上是一个指向底层数组的引用。slice 结构体包含了指向底层数组的指针、slice 的长度和容量。
2. 当创建一个 slice 时,实际上是创建了一个 slice 结构体,而不是直接创建一个新的数组
- 当对 slice 进行"切片"操作时,新 slice 会指向原有 slice 的部分元素,共享底层数组。
- slice 只是一个指向底层数组的引用,不会自己分配内存,仅保存了指向数组的指针、长度和容量。

## map进行有序的排序：

- 将 map 的键值对转换成一个切片,然后使用 sort.Slice() 函数对切片进行排序。排序时可以自定义比较函数

## go语言协程调度原理，协程为什么快
- 协程调度原理:
- -	M-P-G 模型: Go 语言采用了 M-P-G 的协程调度模型。其中 M 代表 OS 线程(Machine)、P 代表逻辑处理器(Processor)、G 代表协程(Goroutine)。
- -	P 和 G: 每个 P 都有自己的协程队列,管理着一组 G。P 会从自己的协程队列中取出 G 并执行。当一个 G 被阻塞(例如 I/O 操作)时,P 会将它暂时放到自己的协程队列中,然后执行其他 G。
- - M 和 P: 一个 M 可以绑定多个 P,但一个 P 只能绑定一个 M。当一个 P 的 G 全部被阻塞时,M 会寻找其他 P 的就绪 G 来执行。

- 为什么快：轻量级、并发效率高、抢占式调度


## 逃逸的场景有哪些，主要是因为什么引起的
1. 返回局部变量的地址:
-	当一个函数返回一个局部变量的地址时,该变量就会逃逸到堆上。
-	因为函数返回后,局部变量的生命周期超出了函数的范围,必须分配在堆上才能保证安全。
2. 向函数外部传递局部变量:
-	如果将一个局部变量的地址传递给函数外部的变量,该局部变量就会逃逸。
-	原因同上,局部变量的生命周期超出了函数的范围。
3. 动态分配的内存:
-	使用 new() 或 make() 动态分配的内存空间,其地址会逃逸到堆上。
-	因为这些动态分配的内存空间,其生命周期是不确定的,无法确定是否可以放在栈上。
4. 接口类型的变量:
-	当一个变量赋值给接口类型的变量时,该变量可能会逃逸。
-	这是因为接口类型需要额外的信息来描述底层的具体类型,这些信息需要存储在堆上。
5. 闭包:
-	当一个函数内部定义并返回了一个闭包时,闭包引用的外部变量就会逃逸。
-	这是因为闭包需要保留对外部变量的引用,因此这些变量必须分配在堆上。
6. slice、map 和 channel:
-	这些复合数据类型的底层实现通常需要在堆上分配内存,因此它们的元素也会逃逸

